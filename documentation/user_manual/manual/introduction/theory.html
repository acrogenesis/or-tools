

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>1.4. A little bit of theory &mdash; or-tools User&#39;s Manual</title>

    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="1. Introduction to constraint programming" href="../introduction.html" />
    <link rel="next" title="1.5. The three-stage method: describe, model and solve" href="three_stages.html" />
    <link rel="prev" title="1.3. Real examples" href="real_examples.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="three_stages.html" title="1.5. The three-stage method: describe, model and solve"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="real_examples.html" title="1.3. Real examples"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../introduction.html" accesskey="U">1. Introduction to constraint programming</a> &raquo;</li>
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">

  <div class="section" id="a-little-bit-of-theory">
<span id="id1"></span><h1>1.4. A little bit of theory</h1>
<p>Here you will find some important ideas and
the vocabulary we use throughout this manual. As is often the case with theory, if you don&#8217;t have some first-hand experience with
practice (in this case <em>mathematical optimization</em>), you might find it difficult to follow the theoretical abstraction and technicalities.
To help you get mixed up, experts often mix terms and use (wrongly formulated) shortcuts when they describe their theory. Optimization is certainly no exception. We&#8217;ll try to be as clear as
possible and use specific examples to illustrate the most important concepts. We also try not to oversimplify too much but from time to time, we do to give you
a a simple formulation to a complex theory.</p>
<p>In the subsection <a class="reference internal" href="#constraint-satisfaction-problem"><em>Constraint Satisfaction Problems (CSP) and Constraint Optimization Problems (COP)</em></a>,
we cover the basic vocabulary used to describe the problems we solve in CP. The subsection
<a class="reference internal" href="#complexity-in-a-few-lines"><em>Complexity theory in a few lines</em></a> is an informal introduction to <em>complexity theory</em><a class="footnote-reference" href="#time-complexity" id="id2">[1]</a>.
One of the difficulties of this
theory is that there are lots of technical details no to be missed. We introduce you to important ideas without being drawn into too many details
(some <em>unavoidable</em> details can be found in the footnotes).</p>
<p>Complexity theory is relatively new (it really started in the &#8216;70s)
and is not easy (and after reading this section, you&#8217;ll probably have more questions than answers).
If you are allergic to theory, skip subsection <a class="reference internal" href="#complexity-in-a-few-lines"><em>Complexity theory in a few lines</em></a>. We are convinced - we took the time to write it, right? - that
you would benefit from reading this section in its entirety but it is up to you. You might want to read the important <strong>practical</strong> implications of this
complexity theory in the subsection <a class="reference internal" href="#pratical-aspect-of-intractability"><em>The practical aspect of intractability</em></a> though.</p>
<div class="section" id="constraint-satisfaction-problems-csp-and-constraint-optimization-problems-cop">
<span id="constraint-satisfaction-problem"></span><h2>1.4.1. Constraint Satisfaction Problems (CSP) and Constraint Optimization Problems (COP)</h2>
<p>We illustrate the different components of a
Constraint Satisfaction Problem with the 4-Queens problem we saw in the section <a class="reference internal" href="4queens.html#four-queens-problem"><em>The 4-Queens Problem</em></a>.
Each time, we use a general definition (for instance variable <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/>) and then illustrate this definition by
the 4-Queens problem (for instance variable <img class="math" src="../../_images/math/b77453505fc5ba87f06001a293090b221374b9be.png" alt="x_{21}" style="vertical-align: -4px"/>).</p>
<p id="index-0">A <strong>Constraint Satisfaction Problem (CSP)</strong> consists of</p>
<blockquote>
<div><ul>
<li><p class="first">a set of <strong>variables</strong> <img class="math" src="../../_images/math/2ab231acf867ace39541437bedcff17c1b25dbf8.png" alt="X = \{x_0, \ldots, x_{n-1}\}" style="vertical-align: -5px"/>.</p>
<p>For the 4-Queens Problem, we have a binary variable <img class="math" src="../../_images/math/9ff77ee087b4287c6e82e414efbe4d79aba8c012.png" alt="x_{ij}" style="vertical-align: -6px"/> indicating the presence or not of a queen
on square <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>:</p>
<div class="math">
<p><img src="../../_images/math/2d6d87903738beba57de44b06cea25fe378f5514.png" alt="X = \{x_{00}, x_{01}, x_{02}, x_{03}, x_{10}, x_{11}, x_{12},  \ldots, x_{33}\}"/></p>
</div></li>
<li><p class="first">a <strong>domain</strong> for each variable <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/>, i.e. a <em>finite</em> set <img class="math" src="../../_images/math/8dfcbccbc64a91b700ee90d800d2d0a0c2cda992.png" alt="D_i" style="vertical-align: -3px"/> of possible values.</p>
<p>For the 4-Queens Problem, each variable <img class="math" src="../../_images/math/9ff77ee087b4287c6e82e414efbe4d79aba8c012.png" alt="x_{ij}" style="vertical-align: -6px"/> is a binary variable, thus</p>
<div class="math">
<p><img src="../../_images/math/a8d0161c43b8f45e2a6ca59e393dde658de4e228.png" alt="D_{00} = D_{01} = \ldots = D_{33} = \{0,1\}."/></p>
</div></li>
<li><p class="first">a set of <strong>constraints</strong> that restrict the values the variables can take simultaneously.</p>
<p>For the 4-Queens Problem, we have a set of constraints that forbid two queens (or more) to share the same row:</p>
<div class="math">
<p><img src="../../_images/math/62fd4cd6d4f046d90bc0ec2bbcaa77fa143eb788.png" alt="\begin{array}{rlcr}
\text{row 0:} &amp; x_{00} + x_{01} + x_{02} + x_{03} &amp; \leqslant &amp; 1\\
\text{row 1:} &amp; x_{10} + x_{11} + x_{12} + x_{13} &amp; \leqslant &amp; 1\\
\text{row 2:} &amp; x_{20} + x_{21} + x_{22} + x_{23} &amp; \leqslant &amp; 1\\
\text{row 3:} &amp; x_{30} + x_{31} + x_{32} + x_{33} &amp; \leqslant &amp; 1\\
\end{array}"/></p>
</div><p>Indeed, these constraints ensure that for each row <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> at most one variable
<img class="math" src="../../_images/math/e79980f9fd9ede8a2762d150d907ecc53482a190.png" alt="x_{i0}, x_{i1}, x_{i2}" style="vertical-align: -4px"/> or
<img class="math" src="../../_images/math/26a8a694a69baf9a65d32b4407138e7991979341.png" alt="x_{i3}" style="vertical-align: -3px"/> could take the value <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/>. Actually, we could replace the inequalities by equalities because
we know that every feasible solution must have a queen on each row<a class="footnote-reference" href="#what-exactly-is-the-nqueens-problem" id="id3">[2]</a>. Later, in the
section <a class="reference internal" href="../search_primitives/basic_model_implementation.html#nqueen-implementation-basic-model"><em>Implementation of a basic model</em></a>, we will provide
another model with different variables and constraints.</p>
</li>
</ul>
</div></blockquote>
<p>As we mentioned earlier, values don&#8217;t need to be integers and constraints don&#8217;t need to be
algebraic equations or inequalities<a class="footnote-reference" href="#only-constraint-on-constraint-in-cp" id="id4">[3]</a>.</p>
<p id="index-1">If we want to <em>optimize</em>, i.e. to <em>minimize</em> or <em>maximize</em> an <em>objective function</em>, we talk about a <strong>Constraint Optimization
Problem (COP)</strong>. The <strong>objective function</strong> can be one of the variables of the problem or a function of some or all the variables. Most of the problems
used in this manual fall into this category. In this manual, we&#8217;ll discuss among others:</p>
<ul class="simple">
<li><a class="reference internal" href="../first_steps.html#chapter-first-steps"><em>Cryptarithmetic Puzzles</em></a> (CSP)</li>
<li><a class="reference internal" href="../objectives.html#chapter-using-objectives"><em>The Golomb Ruler Problem</em></a> (COP)</li>
<li><a class="reference internal" href="../search_primitives.html#chapter-search-primitives"><em>The n-Queens Problem</em></a> (CSP)</li>
<li><a class="reference internal" href="../LS.html#chapter-local-search"><em>The Job-Shop Problem</em></a> (COP)</li>
<li><a class="reference internal" href="../TSP.html#chapter-tsp-with-constraints"><em>The Travelling Salesman Problems with time windows</em></a> (COP)</li>
<li><a class="reference internal" href="../VRP.html#chapter-vrp-with-constraints"><em>The Capacitated Vehicle Routing Problem</em></a> (COP)</li>
</ul>
</div>
<div class="section" id="problems-instances-and-solutions">
<span id="problems-instances-solutions"></span><h2>1.4.2. Problems, instances and solutions</h2>
<p id="index-2">We will not go into details about what a <em>mathematical</em> problem exactly is. As an example, we met the n-Queens Problem in the section <a class="reference internal" href="4queens.html#four-queens-problem"><em>The 4-Queens Problem</em></a>. We would like to take the time
to differentiate <em>mathematical</em> problems from <em>real</em> problems though. Let&#8217;s take an example. Let&#8217;s say you are a company and want to give your users the ability to view streets from the comfort
of their browsers as if they were physically present in those remote locations. To provide such a service, you might want to scour the globe with special cars and other mobile means to take some pictures.
This is a <em>real</em> problem from <em>real</em> life. How do you provide such a service? Mathematical optimization to the rescue! Subdivide this real (and challenging!) problem into smaller ones and translate
them into (solvable) mathematical problems:</p>
<ul class="simple">
<li>Taking pictures? All and well but how do you actually do this? How many pictures do you need to take? At what angle? How do you morph them together and minimize distortion? Etc....</li>
<li>How do you scour the streets of a city? At what speed? How close to pictured objects? With how many cars? At what time of the day? After covering a street, where should the car head next? What about turns? Etc....</li>
<li>How do you keep such information on the servers? How do you match the pictures with the correct locations? How do you respond to a user request such that she gets the most relevant information as quickly
as possible? Etc....</li>
<li>...</li>
</ul>
<p>Believe it or not, you can translate those questions into mathematical problems. And these (some of them at least) mathematical problems can be (and are!) solved with tools like the <em>or-tools</em> library.</p>
<p>Mathematical problems are a translation of such real problems into mathematical terms. We&#8217;ll see many of them in this manual. Interestingly enough, the <em>or-tools</em> CP solver doesn&#8217;t have a <tt class="docutils literal"><span class="pre">Model</span></tt> class
on its own as the model is constructed in/by the solver itself but you have some classes that relate to the mathematical model the solver is trying to solve. Among them, you have a <tt class="docutils literal"><span class="pre">ModelVisitor</span></tt> class that lets you <em>visit</em> the model and act upon it.</p>
<p id="index-3">These mathematical problems are sort of theoretical templates. What you want to solve with a computer are specific versions of a problem. For instance, the n-Queens problem with <img class="math" src="../../_images/math/3bd075cc63abd292fe7a0f0fb52afd8390ca5649.png" alt="n=37" style="vertical-align: 0px"/> or
<img class="math" src="../../_images/math/49526bc5b02da6810703a5620d7854599938ee9d.png" alt="n=6484" style="vertical-align: -1px"/>, or a Travelling Salesman Problem on a particular graph representing the city of New York. We call these practical materialization of a mathematical problem <strong>instances</strong>. You try
to find mathematical theoretical methods to solve mathematical problems and solve specific instances on your computer<a class="footnote-reference" href="#instances-vs-problems" id="id5">[4]</a>. When you ask the CP solver to print a model, you
are in fact asking for a specific instance.</p>
<p id="index-4">A <strong>solution</strong> of an instance is an assignment of the variables: each variable is assigned a value of its domain. This doesn&#8217;t mean that a <em>solution</em> solves your problem: the assignment doesn&#8217;t need
to respect the constraints! A <strong>feasible solution</strong> to a CSP or a COP is a <em>feasible</em> assignment: every variable has been assigned a value from its domain
in such a way that <strong>all</strong> the constraints of the model are satisfied. The <em>or-tools</em> CP solver uses the class <tt class="docutils literal"><span class="pre">Assignment</span></tt> to represent a solution. As its mathematical counterpart, it can represent a valid (i.e. a feasible) solution or not. When we have a feasible solution, we&#8217;ll talk about a <tt class="docutils literal"><span class="pre">Solution</span></tt> (<tt class="docutils literal"><span class="pre">SolutionCollector</span></tt> and <tt class="docutils literal"><span class="pre">SolutionPool</span></tt> classes or the <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> method for instance) in <em>or-tools</em> although there is no
<tt class="docutils literal"><span class="pre">Solution</span></tt> class. The <strong>objective value</strong> of a feasible solution is
the value of the objective function for this solution. In <em>or-tools</em>, the objective function is modeled by the <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> class, i.e. it is a variable.
An <strong>optimal solution</strong> to a COP is a feasible solution such
that there are no other solutions with better objective values. Note that an optimal solution doesn&#8217;t need to exist nor is it
unique in general. For instance, we&#8217;ll see that the n-Queens Problem or the Golomb Ruler Problem both possess several optimal solutions.</p>
<p>Let us emphasize that the or-tools CP-solver deals only with discrete and finite variables, i.e. the values
a variable can take are elements of a finite set. If you want to solve a continuous problem,
you need to <em>discretize</em> it, i.e. model your problem with variables over a finite domain.</p>
</div>
<div class="section" id="complexity-theory-for-the-hurried-reader">
<span id="two-important-ideas-complexity-theory-hurried-reader"></span><h2>1.4.3. Complexity theory for the hurried reader</h2>
<p>If you prefer not to read the next section (or if you want a good preparation to read it!), we have summarized its main ideas:</p>
<ul class="simple">
<li>problems are divided in two categories<a class="footnote-reference" href="#more-than-one-category" id="id6">[5]</a>: <strong>easy</strong>
(<img class="math" src="../../_images/math/14ff51e70197053469742052bdebe94cb064ae51.png" alt="\text{P}" style="vertical-align: -1px"/> problems) and <strong>hard</strong> (<img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/> or <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problems)
problems. Hard problems are also called <em>intractable</em><a class="footnote-reference" href="#intractable" id="id7">[6]</a> and in general we only can find
approximate solutions for such problems<a class="footnote-reference" href="#good-vs-proven" id="id8">[7]</a>.
Actually, the question of being able to find exact solutions to hard problems is still open (See the box
&#8220;The <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question&#8221; below);</li>
</ul>
</div>
<div class="section" id="complexity-theory-in-a-few-lines">
<span id="complexity-in-a-few-lines"></span><h2>1.4.4. Complexity theory in a few lines</h2>
<p id="index-5">Some problems such as the <em>Travelling Salesman Problem</em> (see the chapter <a class="reference internal" href="../TSP.html#chapter-tsp-with-constraints"><em>Travelling Salesman Problems with constraints: the TSP with time windows</em></a>)
are hard to solve<a class="footnote-reference" href="#difficult-to-solve" id="id9">[8]</a>:
no one could ever come up
with an efficient algorithm to solve this problem. On the other hand, other problems,
like the <em>n-Queens Problem</em>
(see the chapter <a class="reference internal" href="../search_primitives.html#chapter-search-primitives"><em>Defining search primitives: the n-Queens Problem</em></a>), are solved very efficiently<a class="footnote-reference" href="#precision-on-both-problems" id="id10">[9]</a>.
In the &#8216;70s, complexity experts were able to translate this
fact into a beautiful <em>complexity theory</em>.</p>
<p>Hard to solve problems are called <em>intractable</em> problems. When you cannot solve an intractable
problem to optimality, you can
try to find good solutions or/and <em>approximate</em> the problem. In the &#8216;90s, complexity experts continued their
investigation on the
complexity of solving problems and developed what is now known as the <em>approximation complexity theory</em>. Both theories
are quite new,
very interesting and ... not easy to understand. We try the <em>tour the force</em> to introduce the basics of the general complexity theory in a few lines.
We willingly kept certain technical details out of the way. These technical details <em>are important</em> and actually without
them, you can not construct a complexity theory.</p>
<div class="section" id="intractability">
<span id="id11"></span><h3>1.4.4.1. Intractability</h3>
<p>One of the main difficulties complexity experts faced in the &#8216;70s was to come up with a theoretical
definition of the complexity
of problems not algorithms. Indeed, it is relatively easy<a class="footnote-reference" href="#complexity-algo-difficult" id="id12">[11]</a> to define a complexity measure of
algorithms but how would you define
the complexity of a problem? If you have an efficient algorithm to solve a problem, you could say that the problem
belongs to the set of easy problems but what about difficult problems?
The fact that we don&#8217;t know an efficient algorithm to solve
these doesn&#8217;t mean these problems are really difficult. Someone could come up one day with an efficient algorithm.
The solution the experts came up with was to build equivalence classes between problems and define the complexity of
a problem with respect to the complexity of other problems (so the notion of complexity is relative not absolute<a class="footnote-reference" href="#complexity-relative-for-hard-problems" id="id13">[10]</a>):
a problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> is as hard as a problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> if there exists an efficient transformation <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" style="vertical-align: 0px"/>
that maps every
instance <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> of
problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> into an instance <img class="math" src="../../_images/math/02d7934c9901da21b547877d23334c29af27e2e6.png" alt="\tau(b) = a" style="vertical-align: -4px"/> of problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> such that if you solve <img class="math" src="../../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a" style="vertical-align: 0px"/>,
you solve <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/>.</p>
<img alt="../../_images/reduction.png" class="align-center" src="../../_images/reduction.png" style="height: 150px;" />
<p>Indeed, if there exists an efficient algorithm to solve
problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>, you can also solve efficiently problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/>: transform an instance <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> into into
an instance <img class="math" src="../../_images/math/02d7934c9901da21b547877d23334c29af27e2e6.png" alt="\tau(b) = a" style="vertical-align: -4px"/> of problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> and solve it with the efficient algorithm known to solve problem
<img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>. We write <img class="math" src="../../_images/math/408da4b75f34fba020ef25fd2f0ce35769b11b56.png" alt="B \leqslant_{\text{T}} A" style="vertical-align: -4px"/> and say that problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> <em>reduces efficiently</em>
to problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>
and that <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" style="vertical-align: 0px"/> is an <em>efficient reduction</em><a class="footnote-reference" href="#alanturingt" id="id14">[12]</a>.
The search for an efficient algorithm is replaced by the search for an efficient reduction between
instances of two problems to prove &#8220;equivalent&#8221; complexities.</p>
<p>This main idea leads to a lot of technicalities:</p>
<blockquote>
<div><ul class="simple">
<li>how to exactly measure the complexity of an algorithm?</li>
<li>what is an efficient transformation/reduction?</li>
<li>what are the requirements for such a reduction?</li>
<li>...</li>
</ul>
</div></blockquote>
<p>We don&#8217;t answer these interesting questions except the one on efficiency. We consider a reduction
<img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" style="vertical-align: 0px"/> <em>efficient</em>
if there exist a polynomial-time bounded algorithm (this refers to the first question...) that can transform any
instance <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> of problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> into an instance <img class="math" src="../../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a" style="vertical-align: 0px"/> of problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> such that the solutions
correspond. This also means that we
consider an algorithm <em>efficient</em> if it is <em>polynomially time-bounded</em> (otherwise the efficiency of the
reduction would be useless).</p>
<p>The class of problems that can be efficiently solved is called <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/>, i.e. the class of problems that can be solved by
a polynomial-time bounded algorithm<a class="footnote-reference" href="#p-technically-speaking" id="id15">[13]</a><a class="footnote-reference" href="#p-in-practice" id="id16">[14]</a>.</p>
<p>Some problems are difficult to solve but once you have an answer, it is quite straightforward to verify that a
given solution is indeed the solution of the problem. One such problem is the <em>Hamiltonian Path Problem (HPP)</em>.
Given a graph, is there a path that visits each vertex exactly once? Finding such a path is difficult but verifying
that a given path is indeed an Hamiltonian path, i.e. that it passes exactly once through each vertex, can be
easily done. Problems for which solutions are easy to verify, i.e. for which this verification can be done
in polynomial time, are said to be in the class <img class="math" src="../../_images/math/35e650cafa2f70ede1a3563843e1f75c539761f8.png" alt="NP" style="vertical-align: 0px"/><a class="footnote-reference" href="#np-term" id="id17">[15]</a>. <img class="math" src="../../_images/math/0a9e39774d93f4876b7a540ea26f6fa9c6b756de.png" alt="P \subset NP" style="vertical-align: -1px"/> because if you can
find a solution in polynomial time, you can also verify this solution in polynomial time (just construct it).
Whether we have equality or not
between these two sets is one of the major unsolved theoretical questions in Operations Research (see the box
&#8220;The <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question&#8221; below).</p>
<p>Not all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> seem to be of equal complexity. Some problems, such as the HPP are as hard as any problem
in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>. Remember our classification of the complexity of problems? This means that every problem in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> can
be transformed in polynomial time into the HPP. The hardest problems of <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> form the class of <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problems.</p>
<div class="topic">
<p class="topic-title first">How can you prove that all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> are reducible to a single problem?</p>
<p>Wait a minute. There is an infinite number of problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>, many of which are unknown to us.
So, how is it possible to prove that all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> can be reduced to a single problem?</p>
<p>This can done in two steps:</p>
<ol class="arabic">
<li><p class="first">First, notice that the reduction is <em>transitive</em>. This means that if <img class="math" src="../../_images/math/afc8ad1f66ffd169e136847ae1657634c76a2b01.png" alt="A \leqslant_{\text{T}} B" style="vertical-align: -4px"/>
and <img class="math" src="../../_images/math/13f396961e36a17b6003f97d57f3570021f3588a.png" alt="B \leqslant_{\text{T}} C" style="vertical-align: -4px"/> then <img class="math" src="../../_images/math/294b6cf3a0ca074c040e389b1d4a8eeb0668b1b2.png" alt="A \leqslant_{\text{T}} C" style="vertical-align: -4px"/>. Thus, if you have one problem
<img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/> such that all problems <img class="math" src="../../_images/math/2744600189f7f1df31756f2022b2d5212ef1c767.png" alt="A_i" style="vertical-align: -3px"/> in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> are reducible to <img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/>, i.e.
<img class="math" src="../../_images/math/8d96799a95dd8394032126d1e922b013ebf7d8bd.png" alt="A_i \leqslant_{\text{T}} Z" style="vertical-align: -4px"/>, then to prove that all problems <img class="math" src="../../_images/math/2744600189f7f1df31756f2022b2d5212ef1c767.png" alt="A_i" style="vertical-align: -3px"/> in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> reduce
to a problem <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/>, you just need to prove that <img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/> reduces to <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/>. Indeed, if
<img class="math" src="../../_images/math/03cd569166253c4b4dc478fd5c3e1422320d5eea.png" alt="Z \leqslant_{\text{T}} X" style="vertical-align: -4px"/> then <img class="math" src="../../_images/math/a6424038c88a1a647334e34763742da942f09abc.png" alt="A_i \leqslant_{\text{T}} Z \leqslant_{\text{T}} X" style="vertical-align: -4px"/><a class="footnote-reference" href="#to-prove-np-completeness" id="id18">[16]</a>.</p>
<p>This only works <strong>if</strong> you can find such problem <img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/>. Well, such problem has been found, see next point.</p>
<p>The funny fact is that if <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/> is in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>, then <img class="math" src="../../_images/math/d356cf20d4a30e4d146ccf0dfbbf19510e03e5a3.png" alt="X \leqslant_{\text{T}} Z" style="vertical-align: -4px"/> also. Such problems are called <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/>
and we just showed that if you can solve one problem in <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> efficiently, you can solve all the problems
in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> efficiently!</p>
</li>
<li><p class="first">Several researchers (like for example Cook and Levin in the early &#8216;70s,
see <a class="reference external" href="https://en.wikipedia.org/wiki/Cook%27s_theorem">Wikipedia on the Cook-Levin Theorem</a>), were able to
prove that
all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> are reducible in polynomial time to the <em>Boolean Satisfiability Problem</em> (SAT) and this problem is of course in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>.</p>
<p>Proving that the SAT problem is <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> is a major achievement in the complexity
theory (all existing proves are highly technical).</p>
</li>
</ol>
</div>
<p>Finally, if a problem is as hard as an <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problem, it is called an <img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/> problem.
Optimization problems, whose decision version belong to <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/>, fall into this category.</p>
<p>The next figure summarizes the relations between the complexity classes<a class="footnote-reference" href="#zoo-complexity-classes" id="id19">[17]</a> we have seen as most of the experts believe they stand, i.e. <img class="math" src="../../_images/math/ed4d62c5fa27cfbba79f8b58a2c8aba71c5d6d68.png" alt="\text{P} \neq \text{NP}" style="vertical-align: -4px"/>.</p>
<img alt="../../_images/complexity_classes.png" class="align-center" src="../../_images/complexity_classes.png" style="height: 250px;" />
<div class="topic" id="thepvsnpquestion">
<p class="topic-title first">The <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question</p>
<p>The P versus NP problem is a major unsolved problem in Computer Science. Informally, it asks whether every problem whose solution can be quickly verified by a computer (<img class="math" src="../../_images/math/71a2fd14e03e9dd7dc3ad58b450d7f56ab84bea2.png" alt="\in \text{NP}" style="vertical-align: -1px"/>) can also be quickly solved by a computer (<img class="math" src="../../_images/math/294fb5dad480e2dbd014ac72779885cad691fe0e.png" alt="\in \text{P}" style="vertical-align: -1px"/>). It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute. The offered prize
to the first team to solve this question is $1,000,000!</p>
<p>In 2002 and 2012, W. I. Gasarch (see <a class="reference internal" href="#gasarch2002">[Gasarch2002]</a> and <a class="reference internal" href="#gasarch2012">[Gasarch2012]</a>) conducted a poll and asked his
colleagues what they thought
about the <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question. Here are the results:</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="19%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Outcome<a class="footnote-reference" href="#gasarch-more" id="id22">[18]</a></th>
<th class="head">% (2002)</th>
<th class="head">% (2012)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img class="math" src="../../_images/math/4811a569c64f4862145541b21ecdcff2798ad9bb.png" alt="P \neq NP" style="vertical-align: -4px"/></td>
<td>61</td>
<td>83</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../../_images/math/e2dcb2b67c648906ad2d87fc1ef1ceb46ea6df7d.png" alt="P = NP" style="vertical-align: 0px"/></td>
<td>9</td>
<td>9</td>
</tr>
<tr class="row-even"><td>No idea</td>
<td>30</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>One possible outcome - mentioned by very few - is that this question could be... undecidable, i.e. there is no
<em>yes</em> or <em>no</em> answer<a class="footnote-reference" href="#undecidable" id="id23">[19]</a>!</p>
</div>
<br><p>If you are interested in this fascinating subject, we recommend that you read the classical book
<em>Computers and Intractability: A Guide to the Theory of NP-Completeness</em> from M. R. Garey and D. S. Johnson (see
<a class="reference internal" href="#garey1979">[Garey1979]</a><a class="footnote-reference" href="#garey-outdated" id="id25">[20]</a>).</p>
</div>
<div class="section" id="the-practical-aspect-of-intractability">
<span id="pratical-aspect-of-intractability"></span><h3>1.4.4.2. The practical aspect of intractability</h3>
<p>If you try to solve a problem that is proven to be <img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/>, you know that it is
probably an intractable problem (if <img class="math" src="../../_images/math/4811a569c64f4862145541b21ecdcff2798ad9bb.png" alt="P \neq NP" style="vertical-align: -4px"/>). At least, you know that no one could ever come with an efficient
algorithm to solve it and that it is unlikely to happen soon. Thus, you are not able to solve exactly &#8220;big&#8221; instances of your
problem. What can you do?</p>
<p>Maybe there are special cases that can be solved in polynomial time? If you are not interested in those cases and
your instances are too big to be solved exactly, even with parallel and/or decomposition algorithms, then there is only
one thing to do: approximate your problem and/or the solutions.</p>
<p>You could simplify your problem and/or be satisfied with an approximation, i.e. a solution that is not exact nor optimal.
One way to do this in CP is to relax the model by softening some constraints<a class="footnote-reference" href="#softening-constraints" id="id26">[21]</a>. In a nutshell,
you soften a constraint by allowing this constraint to be violated. In a approximate solution where the constraint is
violated, you penalize the objective function by a certain amount corresponding to the violation. The bigger the
violation, the bigger the penalty. The idea is to find a solution that doesn&#8217;t violate too much the soft constraints in
the hope that such approximate solution isn&#8217;t that different from an exact or optimal solution<a class="footnote-reference" href="#different-solution-optimization" id="id27">[22]</a>.</p>
<p>Another possible research avenue is to use <em>(meta-)heuristics</em>: algorithms that hopefully return good or even near-optimal
solutions. Some of these algorithms give a guarantee on the quality of the produced solutions, some don&#8217;t
and you just hope for the best. You can also monitor the quality of the solutions by trying to close the <em>optimality gap</em> as
much as possible. Given an instance, compute a <em>lower bound</em> <img class="math" src="../../_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha" style="vertical-align: 0px"/> and an <em>upper bound</em> <img class="math" src="../../_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta" style="vertical-align: -4px"/> on the
optimal value <img class="math" src="../../_images/math/59f327b60c02506ded1dccdc34b1df7a509e8044.png" alt="z^*" style="vertical-align: 0px"/>. So you know that <img class="math" src="../../_images/math/6d76de0e4f0ec475d7d710d006b1d25e2164910a.png" alt="z^* \in [\alpha, \beta]" style="vertical-align: -5px"/>. <em>Closing the optimality gap</em> is trying
to shrink this interval by producing better upper and lower bounds. If you manage to produce solutions with
objective values belonging to this interval, you know how close (or not) these values are from the optimal value of your
instance.</p>
<p>As with exact optimization, an approximation complexity theory emerged. It started in the &#8216;90 and is now a mature domain that improves greatly our comprehension
of what we can or can not (theorically) compute. There is a whole zoo of complexity classes. Some problems can be approximated but without any
guarantee on the quality of the solutions, others can be approximated with as much precision as you desire but
you have to pay the price for this precision: the more precision you want the slower your algorithms will be.
For some problems it is hard to find approximations and for others, it is even impossible to find an approximation with
any guarantee whatsoever on its quality!</p>
<h4>Footnotes</h4><table class="docutils footnote" frame="void" id="time-complexity" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>We talk here about <em>Time</em>-complexity theory, i.e. we are concerned with the time we need
to solve problems. There exist other complexity theories, for instance the <em>Space</em>-complexity
theory where we are concerned with the memory space needed to solve problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="what-exactly-is-the-nqueens-problem" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>We have to cautious here about the exact definition of the n-Queens Problem. The version we talk
about is a CSP where we know that we have to place n queens on a an n x n chessboard so that no two queens attack each other.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="only-constraint-on-constraint-in-cp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>Basically, the only requirement for a constraint in CP is its ability to be
propagated. See chapter <a class="reference internal" href="../custom_constraints.html#chapter-custom-constraints"><em>Custom constraints: the alldifferent_except_0 constraint</em></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="instances-vs-problems" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Of course, things are never that simple. The difference between a mathematical problem and an instance is not always that clear. You might want to solve generically the n-Queens
Problem with a <em>meta-algorithm</em> for instance, or the n-Queens Problem could be viewed as an instance of a broader category of problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="more-than-one-category" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>Stated like this, it sounds pretty obvious but this complexity theory is really subtle and full of beautiful (and useful) results. Actually, most problems of
practical interest belong to either categories but these two categories
don&#8217;t cover all problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="intractable" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><em>Intractable problems</em> are problems which in practice take too long to solve exactly, so there
is a gap between the theoretical definition (<img class="math" src="../../_images/math/f92cdaa60529de09ad1683bff22ee9be04dffa28.png" alt="\textrm{NP-Hard}" style="vertical-align: -1px"/> problems) and the
practical definition (<em>Intractable</em> problems).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="good-vs-proven" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>Technically, you could find an exact solution but you would not be able to prove that
it is indeed an exact solution in general.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="difficult-to-solve" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>Roughly, we consider a problem to be hard to solve if we need a lot of time to solve it. Read on.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="precision-on-both-problems" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>The Travelling Salesman Problem is said to be <em>NP-hard</em> while (a version of) the n-Queens Problem is said to be in <em>P</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="complexity-relative-for-hard-problems" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[10]</a></td><td>Well, for... <em>hard</em> problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="complexity-algo-difficult" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td>Well, to a certain degree. You need to know what instances you consider, how these are
encoded, what type of machines you use and so on.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="alanturingt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[12]</a></td><td>The <img class="math" src="../../_images/math/512dc0768885cd763b41f840733bdfe8c31ae1e7.png" alt="\text{T}" style="vertical-align: 0px"/> in <img class="math" src="../../_images/math/60558d78ce54153ab4b7a7a88caa75475b6a8d8c.png" alt="\leqslant_{\text{T}}" style="vertical-align: -4px"/> is in honor of Alan Turing. Different types of
efficient reductions exist.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="p-technically-speaking" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td>For technical reasons, we don&#8217;t compare problems but <em>languages</em> and only consider
<em>decision problems</em>, i.e. problems that have a <em>yes/no</em> answer. The <em>Subset Sum Problem</em> is such a problem.
Given a finite set of integers, is there a non-empty subset whose sum is zero? The answer is yes or no. By extension,
we say an optimization problem is in <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/>, if its equivalent <em>decision problem</em> is in <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/>. For instance,
the Chinese Postman Problem (CPP) is an optimization problem where one wants to find a minimal route
traversing all edges
of a graph. The equivalent decision problem is &#8221; <em>Is it possible to find a feasible route with cost less or equal
to</em> <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/> <em>?</em> &#8221; where <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/> is a given integer. By extension, we will say that the CPP
is in <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/> (we should rather say that the CPP is in <img class="math" src="../../_images/math/965e85c5d394f9b307461c8a8a87a316ba27c079.png" alt="P-\text{optimization}" style="vertical-align: -4px"/>).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="p-in-practice" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[14]</a></td><td>This discussion is really about <em>theoretical</em> difficulties of problems. Some problems that
are theoretically easy (such as solving a Linear System or a Linear Program) are difficult in
practice and conversely, some problems that are theoretically difficult, such as the Knapsack Problem
are routinely solved on big instances.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="np-term" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[15]</a></td><td>The abbreviation <img class="math" src="../../_images/math/35e650cafa2f70ede1a3563843e1f75c539761f8.png" alt="NP" style="vertical-align: 0px"/> refers to <em>non-deterministic polynomial time</em>, not to <em>non-polynomial</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="to-prove-np-completeness" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[16]</a></td><td>If you want to prove that a problem <img class="math" src="../../_images/math/ce58e4af225c93d08606c26554caaa5ae32edeba.png" alt="Y" style="vertical-align: 0px"/> is <img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/> (see below),
take a problem that is <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/>, like the HPP, and reduce it to your problem. This might sound easy
but it is not!</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="zoo-complexity-classes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[17]</a></td><td>Be aware that there are many more complexity classes.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gasarch-more" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[18]</a></td><td>We agglomerated all other answers into a category <em>No idea</em> although the poll
allowed people to fully express themselves (some answered &#8220;I don&#8217;t care&#8221; for instance). The first poll (2002)
involved 100 researchers while the second one involved 152 researchers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="undecidable" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[19]</a></td><td>See <a class="reference external" href="http://en.wikipedia.org/wiki/Undecidable_problem">Undecidable problem on Wikipedia</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="garey-outdated" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[20]</a></td><td>This book was written in 1979 and so misses the last developments of the complexity theory
but it clearly explains the NP-Completeness theory and
provides a long list of NP-Complete problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="softening-constraints" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[21]</a></td><td>For MIP practitioners, this is equivalent to <em>Lagrangian Relaxation</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="different-solution-optimization" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[22]</a></td><td>In the case of optimization, a solution that <em>isn&#8217;t that different</em> means a
solution that has a good objective value, preferably close to the optimum.</td></tr>
</tbody>
</table>
<h4>Bibliography</h4><table class="docutils citation" frame="void" id="gasarch2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[Gasarch2002]</a></td><td><ol class="first last upperalpha simple" start="23">
<li><ol class="first upperroman">
<li>Gasarch. <em>The P=?NP poll</em>, SIGACT News 33 (2), pp 34–47, 2002.</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gasarch2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[Gasarch2012]</a></td><td><ol class="first last upperalpha simple" start="23">
<li><ol class="first upperroman">
<li>Gasarch. <em>The second P =?NP poll</em>, SIGACT News 43(2), pp 53-77, 2012.</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="garey1979" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[Garey1979]</a></td><td>Garey, M. R. and Johnson D. S. <em>Computers and Intractability: A Guide to the Theory of NP-Completeness</em>,
1979, W. H. Freeman &amp; Co, New York, NY, USA, pp 338.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>






<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="https://acrogenesis.com/or-tools/documentation/user_manual/" selected>user's manual</option>
<option value="https://acrogenesis.com/or-tools/documentation/faq/">faq</option>
<option value="https://acrogenesis.com/or-tools/documentation/reference_manual/or-tools/">reference manual</option>
<option value="https://acrogenesis.com/or-tools/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>

  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>
  </ul>





  <h3>Tutorial examples</h3>

  <ul>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_Python">Python</a></li>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>




  <h3>Current chapter</h3>
  <p class="topless"><a href="../introduction.html"
                        title="previous chapter">1. Introduction to constraint programming</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="real_examples.html"
                        title="previous chapter">1.3. Real examples</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="three_stages.html"
                        title="next chapter">1.5. The three-stage method: describe, model and solve</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">1.4. A little bit of theory</a><ul>
<li><a class="reference internal" href="#constraint-satisfaction-problems-csp-and-constraint-optimization-problems-cop">1.4.1. Constraint Satisfaction Problems (CSP) and Constraint Optimization Problems (COP)</a></li>
<li><a class="reference internal" href="#problems-instances-and-solutions">1.4.2. Problems, instances and solutions</a></li>
<li><a class="reference internal" href="#complexity-theory-for-the-hurried-reader">1.4.3. Complexity theory for the hurried reader</a></li>
<li><a class="reference internal" href="#complexity-theory-in-a-few-lines">1.4.4. Complexity theory in a few lines</a><ul>
<li><a class="reference internal" href="#intractability">1.4.4.1. Intractability</a></li>
<li><a class="reference internal" href="#the-practical-aspect-of-intractability">1.4.4.2. The practical aspect of intractability</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="three_stages.html" title="1.5. The three-stage method: describe, model and solve"
             >next</a> |</li>
        <li class="right" >
          <a href="real_examples.html" title="1.3. Real examples"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../introduction.html" >1. Introduction to constraint programming</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2015, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>