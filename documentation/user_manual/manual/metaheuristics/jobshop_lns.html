

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>7.7. Large neighborhood search (LNS): the Job-Shop Problem &mdash; or-tools User&#39;s Manual</title>

    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="7. Meta-heuristics: several previous problems" href="../metaheuristics.html" />
    <link rel="next" title="7.8. Default search" href="default_search.html" />
    <link rel="prev" title="7.6. Guided Local Search (GLS)" href="GLS.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="default_search.html" title="7.8. Default search"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="GLS.html" title="7.6. Guided Local Search (GLS)"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../metaheuristics.html" accesskey="U">7. Meta-heuristics: several previous problems</a> &raquo;</li>
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">

  <div class="section" id="large-neighborhood-search-lns-the-job-shop-problem">
<span id="large-neighborhood-search"></span><h1>7.7. Large neighborhood search (LNS): the Job-Shop Problem</h1>
<p>We have seen in the previous chapter that one of the difficulties of Local Search
is to define the right notion of <em>neighborhood</em>:</p>
<ul class="simple">
<li>too small and you might get stuck in a local optimum;</li>
<li>too big and you might loose precious time exploring huge neighbourhoods without any guarantee to find a good solution.</li>
</ul>
<p>Could we combine advantages of both approaches? Visit huge neighborhoods but only paying
the cost needed to visit small neighborhoods? This is what <strong>Very Large-Scale Neighbourhood (VLSN)</strong><a class="footnote-reference" href="#very-large-scale-neighborhood-methods" id="id1">[1]</a> methods
try to achieve. The basic idea is to create large neighborhoods but to only (heuristically) visit the more interesting
parts of it.</p>
<p><strong>Large Neighbourhood Search (LNS)</strong> is one of those VLN methods and is especially well suited to be combined with
Constraint Programming.</p>
<div class="section" id="what-is-large-neighborhood-search">
<h2>7.7.1. What is Large Neighborhood Search?</h2>
<p>The Large Neighborhood Search (LNS) meta-heuristic was proposed by Shaw in 1998 <a class="reference internal" href="#shaw1998">[Shaw1998]</a>.
The neighborhood of a solution is defined implicitly by a <em>destroy</em> and a <em>repair</em> methods. A destroy method
destroys part of the current solution while a repair method rebuilds the destroyed solution. Typically, the
destroy method contains some randomness such that different parts of the current solution are destroyed and...
different parts of the search tree visited! This means that the neighborhoods can be seen as <em>larger</em> than
in &#8220;classical&#8221; Local Search, hence the name.</p>
<p>In its very basic form, we could formulate large neighborhood search like this:</p>
<img alt="../../_images/LNS_basic_pseudo_code.png" class="align-center" src="../../_images/LNS_basic_pseudo_code.png" style="height: 110pt;" />
<p>Often, steps 1. and 2. are done simultaneously. This is the case in <strong>or-tools</strong>.</p>
<p>It looks very much like Local Search, the only difference is the way the neighborhoods are constructed.</p>
<p>As always, the definition of the destroy and repair methods is a matter of trade-off.</p>
<p>An important concept is the <em>degree of destruction</em>: if only a small part of a solution is destructed, the LNS misses
its purpose and merely becomes a &#8220;classical&#8221; Local Search method acting on small neighborhoods. If a very large part (or the entirety) of the solution
is destructed, then the reconstruction process consists in repeated (full) optimizations from scratch.</p>
<p>Various scenarios are possible for the repair method ranging from reconstructing optimally the destructed (partial)
solution or using weak but very quick heuristics to reconstruct it. In the first case, you obtain the best possible completed
solution but it is often costly, in the second case you obtain a probably bad solution but very quickly. Most probably, you&#8217;ll
want to use an intermediate scenario: devise an heuristic that reconstruct quite quickly not too bad solutions.</p>
<p>When Large Neighborhood Search is used in combination with Constraint Programming, we often use the term <em>fix</em> for the
destroy method and <em>optimize</em> for the repair method. Indeed, the destruction is done by freeing some variables and thus
<em>fixing</em> the remaining ones to their current values and the repairing consists in <em>optimizing</em> this solution
while keeping the fixed variables to their current values.</p>
</div>
<div class="section" id="large-neighborhood-search-in-ortools">
<span id="id3"></span><h2>7.7.2. Large Neighborhood Search in <strong>or-tools</strong></h2>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/dummy_lns.cc">dummy_lns.cc</a></li>
    </ol>
  </li>
</ol></div>
<p>Large Neighborhood Search is implemented with <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s in <strong>or-tools</strong>. For <tt class="docutils literal"><span class="pre">IntVar</span></tt>s, there is
a specialized <tt class="docutils literal"><span class="pre">BaseLNS</span></tt> class that inherits from <tt class="docutils literal"><span class="pre">IntVarLocalSearchOperator</span></tt>. For <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s and <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s,
you can inherit from the corresponding <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s. We&#8217;ll use the <tt class="docutils literal"><span class="pre">BaseLNS</span></tt> class in this sub-section and
inherit from <tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt> when we&#8217;ll try to solve the Job-Shop Problem below.</p>
<p>Our basic example from previous chapter is to minimize the sum of <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/> <tt class="docutils literal"><span class="pre">IntVar</span></tt>s
<img class="math" src="../../_images/math/5255e13997098334c00b0a0914f78560aca93663.png" alt="\{x_0, \ldots, x_{n - 1}\}" style="vertical-align: -5px"/> each with domain <img class="math" src="../../_images/math/a84dc802efb57b155d24b907ce9e7bae8caa359a.png" alt="[0, n - 1]" style="vertical-align: -5px"/>.
We add the fictive constraint <img class="math" src="../../_images/math/3998581fe70d99938ee529064f9a325d816b0584.png" alt="x_0 \geqslant 1" style="vertical-align: -3px"/> (and thus ask for <img class="math" src="../../_images/math/d99c7df79fdcf28896abb2668e7ca622e9355c40.png" alt="n \geqslant 2" style="vertical-align: -3px"/>):</p>
<div class="math">
<p><img src="../../_images/math/2226db382f1803bbaff328788dbc0c9b06e7dfaf.png" alt="\begin{aligned}
&amp; \underset{x_0, ..., x_{n-1}}{\text{min}}
&amp; &amp; x_0 + x_1 + ... + x_{n-1} \\
&amp; \text{subject to:}
&amp; &amp; x_0 \geqslant 1.\\
&amp; &amp; &amp; x_i \in \{0,\ldots, n-1\} \, \text{for} \,  i = 0 \ldots n-1.
\end{aligned}"/></p>
</div><p>For <tt class="docutils literal"><span class="pre">IntVar</span></tt>s, you can use the <tt class="docutils literal"><span class="pre">BaseLNS</span></tt> class. In this <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>, we have redefined the
<tt class="docutils literal"><span class="pre">OnStart()</span></tt> and <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> methods like this:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt></th>
<th class="head"><tt class="docutils literal"><span class="pre">BaseLNS</span></tt></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">OnStart()</span></tt></td>
<td><tt class="docutils literal"><span class="pre">InitFragments()</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt></td>
<td><tt class="docutils literal"><span class="pre">NextFragment()</span></tt></td>
</tr>
</tbody>
</table>
<p>A <em>Fragment</em> is just an <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> containing the indices of the <tt class="docutils literal"><span class="pre">IntVar</span></tt>s to &#8220;destroy&#8221;, i.e. to free.
The other <tt class="docutils literal"><span class="pre">IntVar</span></tt>s keep their current values. The complementary <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> given to the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>
will <em>repair</em> the current solution. The signature of the <tt class="docutils literal"><span class="pre">NextFragment()</span></tt> is as follow:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="n">NextFragment</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">fragment</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This method is a pure virtual method and <strong>must</strong> be defined. To free some variables, you fill the <tt class="docutils literal"><span class="pre">fragment</span></tt> <tt class="docutils literal"><span class="pre">vector</span></tt>
with the corresponding indices. This method returns <tt class="docutils literal"><span class="pre">true</span></tt> if their are still candidates solutions in the neighborhood, <tt class="docutils literal"><span class="pre">false</span></tt>
otherwise (exactly like the <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> method).</p>
<p>Let&#8217;s use a basic LNS to solve our basic problem. We&#8217;ll free one variable at a time in the order given by the <tt class="docutils literal"><span class="pre">std::vector</span></tt>
of <tt class="docutils literal"><span class="pre">IntVar</span></tt>s. First, we initialize the index of the first variable in <tt class="docutils literal"><span class="pre">InitFragments()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">InitFragments</span><span class="p">()</span> <span class="p">{</span> <span class="n">index_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">index_</span></tt> is a <tt class="docutils literal"><span class="pre">private</span></tt> <tt class="docutils literal"><span class="pre">int</span></tt> indicating the current index of the variable we are about to destroy.</p>
<p>The <tt class="docutils literal"><span class="pre">NextFragment()</span></tt> method is straightforward:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">NextFragment</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">fragment</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index_</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fragment</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">index_</span><span class="p">);</span>
    <span class="o">++</span><span class="n">index_</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This time, let&#8217;s repair optimally the destroyed solution. The <tt class="docutils literal"><span class="pre">NestedOptimize</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is exactly what
we need as a complementary <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. It will collapse a search tree described by a
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db</span></tt> and a set of monitors and wrap it into a single point.</p>
<p>There exist several factory methods to construct such a <tt class="docutils literal"><span class="pre">NestedOptimize</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> but all need an <tt class="docutils literal"><span class="pre">Assignment</span></tt> to store the optimal solution found:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Assignment</span> <span class="o">*</span> <span class="k">const</span> <span class="n">optimal_candidate_solution</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeAssignment</span><span class="p">();</span>
<span class="n">optimal_candidate_solution</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
<span class="n">optimal_candidate_solution</span><span class="o">-&gt;</span><span class="n">AddObjective</span><span class="p">(</span><span class="n">sum_var</span><span class="p">);</span>
</pre></div>
</div>
<p>The factory method we will use look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakeNestedOptimize</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span><span class="p">,</span>
                                    <span class="n">Assignment</span><span class="o">*</span> <span class="k">const</span> <span class="n">solution</span><span class="p">,</span>
                                    <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
                                    <span class="n">int64</span> <span class="n">step</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">db</span></tt> is the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> used to optimize, <tt class="docutils literal"><span class="pre">solution</span></tt> stores the optimal solution found (if any),
<tt class="docutils literal"><span class="pre">maximize</span></tt> is a <tt class="docutils literal"><span class="pre">bool</span></tt> indicating if we maximize or minimize and <tt class="docutils literal"><span class="pre">step</span></tt> is the classical step used to optimize.</p>
<p>For our basic example, we use a basic <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to optimize:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="n">optimal_complementary_db</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeNestedOptimize</span><span class="p">(</span>
    <span class="n">s</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span>
                <span class="n">Solver</span><span class="o">::</span><span class="n">CHOOSE_FIRST_UNBOUND</span><span class="p">,</span>
                <span class="n">Solver</span><span class="o">::</span><span class="n">ASSIGN_MAX_VALUE</span><span class="p">),</span>
    <span class="n">optimal_candidate_solution</span><span class="p">,</span>
    <span class="nb">false</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>We then construct our LNS operator:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">OneVarLns</span> <span class="nf">one_var_lns</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
</pre></div>
</div>
<p>and wrap the Local Search:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchPhaseParameters</span><span class="o">*</span> <span class="n">ls_params</span>
        <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhaseParameters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">one_var_lns</span><span class="p">,</span>
                                           <span class="n">optimal_complementary_db</span><span class="p">,</span>
                                           <span class="n">limit</span><span class="p">);</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhase</span><span class="p">(</span><span class="n">initial_solution</span><span class="p">,</span>
                                             <span class="n">ls_params</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">limit</span></tt> is a <tt class="docutils literal"><span class="pre">SearchLimit</span></tt> and <tt class="docutils literal"><span class="pre">initial_solution</span></tt> is our initial solution. When <tt class="docutils literal"><span class="pre">n=4</span></tt>, this
initial solution is <img class="math" src="../../_images/math/9daf9afdc97f1d521ca2f4ca32e905f8e9edfc53.png" alt="[3, 2, 3, 2]" style="vertical-align: -5px"/>.</p>
<p>The simplified output of <strong class="program">dummy_lns</strong> is:</p>
<div class="highlight-bash"><div class="highlight"><pre>Simple Large Neighborhood Search with initial solution

Start search, memory <span class="nv">used</span> <span class="o">=</span> 15.21 MB
Root node processed <span class="o">(</span><span class="nb">time</span> <span class="o">=</span> 0 ms, <span class="nv">constraints</span> <span class="o">=</span> 2, memory <span class="nv">used</span> <span class="o">=</span>
                                                           15.21 MB<span class="o">)</span>
Solution <span class="c">#0 (objective value = 10, ...)</span>
Solution <span class="c">#1 (objective value = 8, ...)</span>
Solution <span class="c">#2 (objective value = 6, ...)</span>
Solution <span class="c">#3 (objective value = 3, ...)</span>
Solution <span class="c">#4 (objective value = 1, ...)</span>
Finished search tree, ..., <span class="nv">neighbors</span> <span class="o">=</span> 10, filtered <span class="nv">neighbors</span> <span class="o">=</span> 10,
                                         accepted <span class="nv">neigbors</span> <span class="o">=</span> 4, ...<span class="o">)</span>
End search <span class="o">(</span><span class="nb">time</span> <span class="o">=</span> 1 ms, <span class="nv">branches</span> <span class="o">=</span> 58, <span class="nv">failures</span> <span class="o">=</span> 57, memory <span class="nv">used</span> <span class="o">=</span>
                                 15.21 MB, <span class="nv">speed</span> <span class="o">=</span> 58000 branches/s<span class="o">)</span>
Objective <span class="nv">value</span> <span class="o">=</span> 1
</pre></div>
</div>
<p>5 solutions were generated with decreased objective
values. <tt class="docutils literal"><span class="pre">Solution</span> <span class="pre">#0</span></tt> is the initial solution given:
<img class="math" src="../../_images/math/9daf9afdc97f1d521ca2f4ca32e905f8e9edfc53.png" alt="[3, 2, 3, 2]" style="vertical-align: -5px"/>. For the next 4 solutions, the <tt class="docutils literal"><span class="pre">NestedOptimize</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> did its job and optimized
the partial solution:</p>
<dl class="docutils">
<dt>neighborhood 1 around <img class="math" src="../../_images/math/175328140da77805addf7d969f61c9e0df20f3dc.png" alt="[3,2,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/98f25bcaf968c85f66afd01b11fe4feb67c125da.png" alt="[-,2,3,2]" style="vertical-align: -5px"/> is immediately taken as the complementary <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> transforms it into the optimal (for this <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>) solution <img class="math" src="../../_images/math/a2e155dc4c6d34c0c8b209dfa1b702bd96840256.png" alt="[1,2,3,2]" style="vertical-align: -5px"/> with an objective value of 8.</dd>
<dt>neighborhood 2  around <img class="math" src="../../_images/math/a2e155dc4c6d34c0c8b209dfa1b702bd96840256.png" alt="[1,2,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/98f25bcaf968c85f66afd01b11fe4feb67c125da.png" alt="[-,2,3,2]" style="vertical-align: -5px"/> is rejected as the optimal solution <img class="math" src="../../_images/math/a2e155dc4c6d34c0c8b209dfa1b702bd96840256.png" alt="[1,2,3,2]" style="vertical-align: -5px"/> doesn&#8217;t have a better objective value than 8.
<img class="math" src="../../_images/math/d7bd61285bfa72545a81de040c02c01d2b6994a2.png" alt="[1,-,3,2]" style="vertical-align: -5px"/> is immediately accepted as the optimal solution constructed is <img class="math" src="../../_images/math/9aa199506aa73098f3645c97321d46ff830e0520.png" alt="[1,0,3,2]" style="vertical-align: -5px"/> with an objective value of 6.</dd>
<dt>neighborhood 3  around <img class="math" src="../../_images/math/9aa199506aa73098f3645c97321d46ff830e0520.png" alt="[1,0,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/3010515ceeb0b173969e370cc46acb837b622b17.png" alt="[-, 0, 3, 2]" style="vertical-align: -5px"/> and <img class="math" src="../../_images/math/d7bd61285bfa72545a81de040c02c01d2b6994a2.png" alt="[1,-,3,2]" style="vertical-align: -5px"/> are rejected and <img class="math" src="../../_images/math/4270dc00d93b45bbdac94c3f2c6ffa76a63f4353.png" alt="[1,0,-,2]" style="vertical-align: -5px"/> is accepted as the optimal solution
constructed is <img class="math" src="../../_images/math/16a64b20b673f9d47a80a721f659a4e7726bb6e1.png" alt="[1,0,0,2]" style="vertical-align: -5px"/> with an objective value of 3.</dd>
<dt>neighborhood 4  around <img class="math" src="../../_images/math/16a64b20b673f9d47a80a721f659a4e7726bb6e1.png" alt="[1,0,0,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/35bc7b3a267c87204236fefbe603eb79e49f6f3d.png" alt="[-, 0, 0, 2]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/da8a2d6368b051ed1915a58813bec0cb785c0577.png" alt="[1, -, 0, 2]" style="vertical-align: -5px"/> and <img class="math" src="../../_images/math/2110829d67b6b936efdbeea243f679c4ec3c8db6.png" alt="[1, 0, -, 2]" style="vertical-align: -5px"/> are rejected while <img class="math" src="../../_images/math/7cef88777c45e887e58044375905b793db021201.png" alt="[1, 0, 0, -]" style="vertical-align: -5px"/> is accepted
as the optimal solution constructed <img class="math" src="../../_images/math/e8e1d5ff72c593aab7d4938dbbc39be2e7f2e958.png" alt="[1,0,0,0]" style="vertical-align: -5px"/> has an objective value of 1.</dd>
</dl>
<p>The two last lines printed by the <tt class="docutils literal"><span class="pre">SearchLog</span></tt> summarize the local search:</p>
<div class="highlight-bash"><div class="highlight"><pre>Finished search tree, ..., <span class="nv">neighbors</span> <span class="o">=</span> 10, filtered <span class="nv">neighbors</span> <span class="o">=</span> 10,
                                         accepted <span class="nv">neigbors</span> <span class="o">=</span> 4, ...<span class="o">)</span>
End search <span class="o">(</span><span class="nb">time</span> <span class="o">=</span> 1 ms, <span class="nv">branches</span> <span class="o">=</span> 58, <span class="nv">failures</span> <span class="o">=</span> 57, memory <span class="nv">used</span> <span class="o">=</span>
                                 15.21 MB, <span class="nv">speed</span> <span class="o">=</span> 58000 branches/s<span class="o">)</span>
Objective <span class="nv">value</span> <span class="o">=</span> 1
</pre></div>
</div>
<p>There were indeed 10 constructed candidate solutions among which 10 (filtered neighbors) were accepted
after filtering (there is none!) and 4 (accepted neighbors) were improving solutions.</p>
<p>For this basic example, repairing optimally led to the optimal solution but this is not necessarily the case.</p>
</div>
<div class="section" id="interesting-lns-operators">
<h2>7.7.3. Interesting LNS operators</h2>
<p>At the moment of writing (28 <sup>th</sup> of February 2015, rev 3845), there are only a few specialized LNS operators. All concern
<tt class="docutils literal"><span class="pre">IntVar</span></tt>s:</p>
<ul class="simple">
<li>There are two basic LNS operators:<ul>
<li><tt class="docutils literal"><span class="pre">SimpleLNS</span></tt>: Frees a number of contiguous variables (à la <img class="math" src="../../_images/math/896dbdbff63bda725faec7bfeec618885320dbb7.png" alt="mod(m)" style="vertical-align: -4px"/>) in the <tt class="docutils literal"><span class="pre">std::vector&lt;IntVar*&gt;</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">RandomLNS</span></tt>: Frees a number <img class="math" src="../../_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m" style="vertical-align: 0px"/> of randomly chosen variables from the <tt class="docutils literal"><span class="pre">std::vector&lt;IntVar*&gt;</span></tt>.</li>
</ul>
</li>
<li>Some <tt class="docutils literal"><span class="pre">PathOperator</span></tt>s. We&#8217;ll see <tt class="docutils literal"><span class="pre">PathOperator</span></tt>s more in details in the section <a class="reference internal" href="../tsp/two_phases_approaches.html#local-search-pathoperators"><em>Local Search PathOperators</em></a>.</li>
</ul>
<div class="section" id="simplelns">
<h3>7.7.3.1. <tt class="docutils literal"><span class="pre">SimpleLNS</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">SimpleLNS</span></tt> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> frees a number of contiguous variables. Its <tt class="docutils literal"><span class="pre">NextFragment()</span></tt> method reads:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">NextFragment</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">fragment</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index_</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index_</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_</span> <span class="o">+</span> <span class="n">number_of_variables_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fragment</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">index_</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The factory method to create this <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> is <tt class="docutils literal"><span class="pre">MakeOperator()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeOperator</span><span class="p">(</span>
                                  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                                  <span class="n">Solver</span><span class="o">::</span><span class="n">LocalSearchOperators</span> <span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">LocalSearchOperators</span></tt> is an <tt class="docutils literal"><span class="pre">enum</span></tt> describing different <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s.
To create a <tt class="docutils literal"><span class="pre">SimpleLNS</span></tt>, we use <tt class="docutils literal"><span class="pre">Solver::SIMPLELNS</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span> <span class="o">*</span> <span class="n">simple_lns</span> <span class="o">=</span>
                             <span class="n">solver</span><span class="p">.</span><span class="n">MakeOperator</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span>
                                                 <span class="n">Solver</span><span class="o">::</span><span class="n">SIMPLELNS</span><span class="p">);</span>
</pre></div>
</div>
<p>By default, the variable <tt class="docutils literal"><span class="pre">number_of_variables_</span></tt> in <tt class="docutils literal"><span class="pre">NextFragment()</span></tt> will be set to 1
and thus <tt class="docutils literal"><span class="pre">SimpleLNS</span></tt> destroys one variable at a time. Unfortunately, <tt class="docutils literal"><span class="pre">SimpleLNS</span></tt> is not accessible directly. If you
want to destroy more than 1 variable, you&#8217;ll have to implement your own <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>.</p>
</div>
<div class="section" id="randomlns">
<h3>7.7.3.2. <tt class="docutils literal"><span class="pre">RandomLNS</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">RandomLNS</span></tt> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> destroys randomly some variables. Its <tt class="docutils literal"><span class="pre">NextFragment()</span></tt> method reads:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">NextFragment</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">fragment</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_variables_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fragment</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">rand_</span><span class="p">.</span><span class="n">Uniform</span><span class="p">(</span><span class="n">Size</span><span class="p">()));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">number_of_variables_</span></tt> represents the number of variables to destroy. As you can see, this method always returns <tt class="docutils literal"><span class="pre">true</span></tt>.
This means that the neighborhood is never exhausted. <tt class="docutils literal"><span class="pre">rand_</span></tt> is an object of type <tt class="docutils literal"><span class="pre">ACMRandom</span></tt> which is
an ACM minimal standard random number generator (see the section <a class="reference internal" href="../utilities/randomness.html#randomness"><em>Randomizing</em></a> for more). <tt class="docutils literal"><span class="pre">rand_.Uniform(Size())</span></tt>
returns a random number between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">Size()</span> <span class="pre">-</span> <span class="pre">1</span></tt>. It might happen that
the same variable is chosen more than once.</p>
<p>There are 2 factory methods to create <tt class="docutils literal"><span class="pre">RandomLNS</span></tt> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeRandomLNSOperator</span><span class="p">(</span>
                                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">number_of_variables</span><span class="p">);</span>
<span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeRandomLNSOperator</span><span class="p">(</span>
                                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">number_of_variables</span><span class="p">,</span>
                                   <span class="n">int32</span> <span class="n">seed</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="a-heuristic-to-solve-the-job-shop-problem">
<span id="an-heuristic-to-solve-the-jobshop-problem"></span><h2>7.7.4. A heuristic to solve the job-shop problem</h2>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_ls.h">jobshop_ls.h</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_lns.h">jobshop_lns.h</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_lns.cc">jobshop_lns.cc</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_heuristic.cc">jobshop_heuristic.cc</a></li>
    </ol>
  </li>
  <li>Data file:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/abz9">abz9</a></li>
    </ol>
  </li>

</ol></div>
<p>We present a basic Large Neighborhood Search operator <tt class="docutils literal"><span class="pre">SequenceLns</span></tt> to solve the Job-Shop Problem in the file <tt class="file docutils literal"><span class="pre">jobshop_lns.cc</span></tt>.
In the file <tt class="file docutils literal"><span class="pre">jobshop_heuristic.cc</span></tt>, we mix all <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s we have seen in the previous
chapter <a class="reference internal" href="../LS.html#chapter-local-search"><em>Local Search: the Job-Shop Problem</em></a> and the <tt class="docutils literal"><span class="pre">SequenceLns</span></tt> operator.</p>
<div class="section" id="sequencelns">
<h3>7.7.4.1. <tt class="docutils literal"><span class="pre">SequenceLns</span></tt></h3>
<p>We define a basic LNS operator: <tt class="docutils literal"><span class="pre">SequenceLNS</span></tt>. This operator destroys <tt class="docutils literal"><span class="pre">current_length</span></tt> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s randomly
in the middle of each <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> as depicted on the next picture:</p>
<img alt="../../_images/sequence_lns.png" class="align-center" src="../../_images/sequence_lns.png" style="width: 700pt;" />
<p>To allow for some diversity, from time to time this operator destroys completely two <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s.</p>
<p>For <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s, there are no specialized LNS operators. We thus inherit from <tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SequenceLns</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SequenceVarLocalSearchOperator</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">SequenceLns</span><span class="p">(</span><span class="k">const</span> <span class="n">SequenceVar</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">vars</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">seed</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">max_length</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">SequenceVarLocalSearchOperator</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
        <span class="n">random_</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span>
        <span class="n">max_length_</span><span class="p">(</span><span class="n">max_length</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">random_</span></tt> is again an object of type <tt class="docutils literal"><span class="pre">ACMRandom</span></tt> and <tt class="docutils literal"><span class="pre">max_length</span></tt> is the maximal number of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s to
destroy in each <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>. It&#8217;s a upper bound because the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> could contain less <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s.</p>
<p>We use again our template for the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">MakeNextNeighbor</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                              <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RevertChanges</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">random_</span><span class="p">.</span><span class="n">Uniform</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">FreeTimeWindow</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">FreeTwoResources</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ApplyChanges</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">VLOG</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Delta = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">delta</span><span class="o">-&gt;</span><span class="n">DebugString</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">FreeTwoResources()</span></tt> simply destroys two random <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">FreeTwoResources</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">free_sequence</span><span class="p">;</span>
  <span class="n">SetForwardSequence</span><span class="p">(</span><span class="n">random_</span><span class="p">.</span><span class="n">Uniform</span><span class="p">(</span><span class="n">Size</span><span class="p">()),</span> <span class="n">free_sequence</span><span class="p">);</span>
  <span class="n">SetForwardSequence</span><span class="p">(</span><span class="n">random_</span><span class="p">.</span><span class="n">Uniform</span><span class="p">(</span><span class="n">Size</span><span class="p">()),</span> <span class="n">free_sequence</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">FreeTimeWindow()</span></tt> is more interesting:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">FreeTimeWindow</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">current_length</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sequence</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">max_length_</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">start_position</span> <span class="o">=</span>
        <span class="n">random_</span><span class="p">.</span><span class="n">Uniform</span><span class="p">(</span><span class="n">sequence</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">current_length</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forward</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">start_position</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">forward</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">backward</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
         <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">start_position</span> <span class="o">+</span> <span class="n">current_length</span><span class="p">;</span>
         <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">backward</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">SetForwardSequence</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">forward</span><span class="p">);</span>
    <span class="n">SetBackwardSequence</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">backward</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We use the <tt class="docutils literal"><span class="pre">SequenceLNS</span></tt> in the file <tt class="file docutils literal"><span class="pre">jobshop_lns.cc</span></tt> to solve the Job-Shop Problem.
Four parameters are defined through <strong class="program">gflags</strong> flags:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">time_limit_in_ms</span></tt>: Time limit in ms, 0 means no limit;</li>
<li><tt class="docutils literal"><span class="pre">sub_sequence_length</span></tt>: The sub sequence length for the <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> LS operator;</li>
<li><tt class="docutils literal"><span class="pre">lns_seed</span></tt>: The seed for the LNS random search;</li>
<li><tt class="docutils literal"><span class="pre">lns_limit</span></tt>: maximal number of candidate solutions to consider for each neighborhood search in the LNS.</li>
</ul>
<p>When we try to solve the <tt class="docutils literal"><span class="pre">abz9</span></tt> instance with our default parameters, we quickly find this solution</p>
<div class="highlight-bash"><div class="highlight"><pre>Solution <span class="c">#190 (objective value = 802, ..., time = 10612 ms, ...,</span>
               <span class="nv">neighbors</span> <span class="o">=</span> 1884, ..., accepted <span class="nv">neighbors</span> <span class="o">=</span> 190, ...<span class="o">)</span>
</pre></div>
</div>
<p>After only 10 seconds, we obtain a feasible solution with an objective value of 802. Much better than what we obtained
in the previous chapter (the best value was 931)! Large Neighborhood Search (and its randomness) widens the scope of the
neighborhood definition and allows to search a bigger portion of the search space but still it doesn&#8217;t avoid the local
trap. <strong class="program">jobshop_lns</strong> seems to get stuck with this solution. In the next sub-section, we use the Local Search
operators defined in the previous chapter and the <tt class="docutils literal"><span class="pre">SequenceLNS</span></tt> operator together.</p>
</div>
<div class="section" id="everything-together">
<h3>7.7.4.2. Everything together</h3>
<p>In the file <tt class="file docutils literal"><span class="pre">jobshop_heuristic.cc</span></tt>, we mix the three <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s we have previously defined:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> and <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> defined in the previous chapter and</li>
<li><tt class="docutils literal"><span class="pre">SequenceLNS</span></tt>.</li>
</ul>
<p>As in <tt class="file docutils literal"><span class="pre">jobshop_ls3.cc</span></tt>, we use Local Search to find an initial solution.
We let the program run for 18 minutes. The best solution found had an objective value of 745 and 717056 candidate solutions
were tested! Maybe <strong class="program">jobshop_heuristic</strong> would have found a better solution after a while but there is no
guarantee whatsoever. We didn&#8217;t <em>tune</em> the algorithm, i.e. we didn&#8217;t try to understand and fix its parameters (all the
<strong class="program">gflags</strong> flags) to their optimal values (if any) and we only used the <tt class="file docutils literal"><span class="pre">abz9</span></tt> instance to test it.</p>
<p>Since we discussed the code in file <tt class="file docutils literal"><span class="pre">jobshop_ls3.cc</span></tt>, the CP Solver has evolved and has been improved in general. Unfortunately, for this precise code the Solver seems to be stuck
in a local optimum with a of value of 809. This might change in the future.</p>
<table class="docutils footnote" frame="void" id="very-large-scale-neighborhood-methods" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><em>Very Large-Scale Neighbourhood</em> methods are more defined by the fact that the neighborhoods
considered are growing exponentially in the size of the input than the way these neighborhoods are explored. But if you want
to explore these huge neighborhoods efficiently, you must do so heuristically, hence our shortcut in the &#8220;definition&#8221; of
<em>Very Large-Scale Neighbourhood</em> methods.</td></tr>
</tbody>
</table>
<h4>Bibliography</h4><table class="docutils citation" frame="void" id="shaw1998" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Shaw1998]</a></td><td>P. Shaw. <em>Using constraint programming and local search methods to solve vehicle routing problems</em>,
Fourth International Conference on Principles and Practice of Constraint Programming, v 1520,
Lecture Notes in Computer Science, pp 417–431, 1998.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>






<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="https://acrogenesis.com/or-tools/documentation/user_manual/" selected>user's manual</option>
<option value="https://acrogenesis.com/or-tools/documentation/faq/">faq</option>
<option value="https://acrogenesis.com/or-tools/documentation/reference_manual/or-tools/">reference manual</option>
<option value="https://acrogenesis.com/or-tools/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>

  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>
  </ul>





  <h3>Tutorial examples</h3>

  <ul>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_Python">Python</a></li>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="https://acrogenesis.com/or-tools/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>




  <h3>Current chapter</h3>
  <p class="topless"><a href="../metaheuristics.html"
                        title="previous chapter">7. Meta-heuristics: several previous problems</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="GLS.html"
                        title="previous chapter">7.6. Guided Local Search (GLS)</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="default_search.html"
                        title="next chapter">7.8. Default search</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.7. Large neighborhood search (LNS): the Job-Shop Problem</a><ul>
<li><a class="reference internal" href="#what-is-large-neighborhood-search">7.7.1. What is Large Neighborhood Search?</a></li>
<li><a class="reference internal" href="#large-neighborhood-search-in-ortools">7.7.2. Large Neighborhood Search in <strong>or-tools</strong></a></li>
<li><a class="reference internal" href="#interesting-lns-operators">7.7.3. Interesting LNS operators</a><ul>
<li><a class="reference internal" href="#simplelns">7.7.3.1. <tt class="docutils literal"><span class="pre">SimpleLNS</span></tt></a></li>
<li><a class="reference internal" href="#randomlns">7.7.3.2. <tt class="docutils literal"><span class="pre">RandomLNS</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-heuristic-to-solve-the-job-shop-problem">7.7.4. A heuristic to solve the job-shop problem</a><ul>
<li><a class="reference internal" href="#sequencelns">7.7.4.1. <tt class="docutils literal"><span class="pre">SequenceLns</span></tt></a></li>
<li><a class="reference internal" href="#everything-together">7.7.4.2. Everything together</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="default_search.html" title="7.8. Default search"
             >next</a> |</li>
        <li class="right" >
          <a href="GLS.html" title="7.6. Guided Local Search (GLS)"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../metaheuristics.html" >7. Meta-heuristics: several previous problems</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2015, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>